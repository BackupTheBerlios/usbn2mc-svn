\chapter{USB verstehen und anwenden}
	\section{USB verstehen}
		\subsection{Warum ist der Einstieg in USB so schwer?}

			USB ist für Embedded Systeme eine ideal Ergänzung. Schnelle Übertragungsraten,
			flexible Kommunikationskanäle, integrierte Stromversorgnung und Echtzeitfähigkeit sind
			nur die bekanntesten Schlagwörter von USB.
			Doch man sieht immer noch oft die klassiche RS232 Verbindung in neuen Projekten,
			obwohl es USB bereits seit 1996 gibt. Warum hat es die
			USB Schnittstelle bis heute nicht geschafft RS232 zu überholen?

		 	Meiner Meinung nach ist das grösste Problem, dass es zu wenig gute Literatur gibt.
			Oft hört man von Entwicklern, das sie sich schon mal USB angeschaut haben, aber dabei
			schnell gemerkt, es reicht nicht kurz etwas drüber zu lesen um sie dann
			einsetzen zu können. Und das liegt daher, dass die meisten Texte und Bücher
			leicht veränderte Übersetzungen von der knapp 1000-seitigen USB Spezifikation sind.

			Die USB Spezifikation ist im Gegensatz zu vielen anderen Spezifikationen
			sehr ausführlich geschrieben. Jedoch 
			ist und bleibt es die Spezifikation von USB, und ist daher völlig ungeeignet als Lernunterlage
			für das Selbststudium.
			
			Und das ist wohl das grösste Problem warum die meisten früh aufgeben. Die Spezifikation
			ist weit weg von einem Produkt oder einer Realisierung, und das ist genau der
			falsche Ansatz zum schnellen einarbeiten.

			Mit dieser Internetseite soll genau diesem Problem entgegengewirkt werden. Es wird
			ein einfaches Modell eingeführt mit dem man schnell in der Lage ist USB verwenden zu
			können.

		\subsection{Ein einfaches Modell zum besseren verstehen}
		Eine USB Schnittstelle hat kein typisches aussehen wie z.B. eine UART Verbindung. 
		Bei einer UART Verbindung gibt es immer mindestens eine TX und RX Leitung. Die TX ist nur 
		dafür da um Daten zu senden, und RX um Daten zu empfangen. Und genau so eine feste Regel gibt es bei USB nicht.

		Es ist möglich parallel mehrer RX und TX Leitungen in einer USB Schnittstelle zu definieren. 
		Dadurch kann man verschiedene Daten über eigene Verbindungen laufen lassen. 
		Stellen wir uns ruhig die USB Schnittstelle kurz mal so vor. Wir können gezielt Daten 
		über verschiedenen Leitungen senden. Wenn wir jetzt eine Soundkarte bauen wollen, 
		brauchen wir zwei TX Leitungen für die zwei Stereokanäle und eine weiteren TX für 
		Steuerkommandos. Um den Zustand der Karte abfragen zu können wäre noch eine RX Leitung sinnvoll.

		Tatsächlich könnte man so eine UART Verbindung nachbauen, nur würde sie wohl keiner nutzen wollen, 
		da man mindestens 3 serielle Schnittstellen auf einem Rechner blockieren würde. 
		Dazu müsste man jedesmal darauf achten, das man ja genau die richtigen Leitungen vom Computer aus mit dem Gerät verbindet.

		Jetzt kommt ein wichtiges Feature von USB ins Spiel. Mit USB kann man dies genau machen. 
		Man kann sich virtuell die Leitungen so hinlegen wie man sie braucht. Damit ein Computer weiss 
		was für Leitungen ein Gerät hat, fragt es dieses nach dem anstecken einfach danach. 

		\subsection{Endpunkte}

		Wir sollten jetzt schnell wieder die Namen TX und RX vergessen und dafür den Namen Endpunkt verwenden,
		denn so werden die Datenübertragungskanäle eines USB Gerätes genannt. Jedem Endpunkt muss eine Richtung und Adresse zugewiesen werden. Eine Adresse gibt es bei der klassichen RS232 Verbindung nicht, da jeder Datenkanal (sprich RX,TX,CTS,RTS usw...) eine eigene Leitung hat. Und hier ist der wohl grösste Unterschied zur klassischen RS232 Verbindung. USB ist wie der Name schon in sich trägt ein Bus. Auf einem Bus werden immer nur Datenpakete übertragen. Daher muss jeder Endpunkt in einem Gerät ebenfalls eine Adresse haben. Da Jedes Gerät vom Betriebssystem nach dem anstecken ebenfalls eine Geräteadresse bekommt, kann man so über die Geräte- und Endpunktadresse direkt diese Datenübertragungskanäle antsteuern. 


		FIFOs müssen hier mit rein.

		ebenfalls die übertragungsarten

Ein Gerät kann maximal 127 Endpunkte haben.

		\subsection{Interface}
	
	Ein Interface ist ein Bündel an Endpunkten. Ein Gerät kann mehrere Interfaces anbieten. So könnte unsere
	Soundkarte ein Interface für den Mono- und eines für den Stereobetrieb haben. Das Interface für den Monobetrieb hat einen Endpunkt für die Steuerkommandos und einen weiteren für die Daten die über einen Lautsprecher ausgegeben werden. Das Interface für den Stereobetrieb hat ebenfalls einen für Steuerkommandos, aber zwei für die Signalausgabe (linker und rechter Kanal). Es kann jederzeit von der Software auf dem PC zwischen den Interfaces hin und hergeschaltet werden. Oft liest man den Begriff Alternate Interface. Dieses Interface kann man parallel zu einem Interface definieren. Wenn man ein normales Interface definiert, gibt man dort die Endpunkte zu diesem an. Entsprechend der FIFO grösse eines Endpunktes wird entsprechend Bandbreite auf den USB Bus reserviert.

daher waere schnell die bandbreite aufgebraucht. wenn man es aber so macht, dass immer nur kurz vor der kommunikation die bandbreite reserviert und danach sofort wieder freigegeben wird, ist eine viel laengere zeit der bus frei fuer andere kommunikationen.

gibt es ein alternate interface zu einem interface so wird beim starten von diesem immer erst das altenate gestartet. das hat den vorteil, dass man schon die richtige schnittstelle (die menge der Endpunkte) vor sich hat, aber nicht den ganzen bus fuer sich reserviert hat. will man jetzt datenaustauschen, so kann man schnell vom alternate interface auf das tatsaechliche wechseln, die daten uebertragen und danach sofort wieder zurueckwechseln. damit ist danach der bus sofort nicht mehr reserviert.

		\subsection{Konfiguration}

		genauso wie interfaces kann ein geraet mehrer konfigurationen haben. ein interface regelt nur die endpunkte sammlung. im gegensatz dazu reguliert eine konfiguration mehr physikalische sachen. 

strom, ..

kamera mit akku betrieb, oder als webcam

		\subsection{Descriptoren}

		\subsection{Plug and Play - Gerätekennung}

		\subsection{USB Klassen}

		\subsection{Ein Gerät mit vielen Gesichtern}


	\section{Geräte-Stack}
		
	\section{Host-Stack}

	\section{USB Debug-Techniken}
		\subsection{Linux - usbmon}
		\subsection{Windows - USB Snoopy}
		\subsection{Windows - ellisys USB Tracker}

	\section{USB Bausteine}
		\section{USB Controller}
		\section{USB Hub Bausteine}
		\section{USB Host Controller}





Und hier stehen wie an einem Punkt, an dem sich die arbeit mit verschiedenen Controller stark unterscheidet. Aber in dem meisten Fällen ist es so, dass die USB Baustein immer einige FIFO Speicher für Endpunkte bereit halten. Das heisst es muss im USB Baustein definiert werden, dass es einen Endpunkt X mit der Adresse Y gibt, und wenn Daten an diesen Endpunkt gesendet werden, sollen diese bitte in den FIFO Nr. Z im USB Baustein abgelegt werden und mir mit einem Interrupt ein Signal gegeben werden. Beim senden arbeitet man meist auch mit internen FIFOs. Hier muss ebenfalls vor der Kommunikation ein FIFO mit einer Endpunktadresse verbunden werden. Dann kann man einfach Daten in den FIFO legen, und der USB Baustein versendet diese entsprechend verpackt mit der richtigen Adresse.


Wenn wir jetzt USB das letzte mal mit RS232 vergleichen will ich den wesentlichen Unterschied nochmal betonen. USB ist ein Bus auf dem Datenpakete hin und her gesendet werden. Bei RS232 hat man direkte Datenleitungen zwischen den Datenkommunikationsstellen. Die RS232 Signale kann man relativ einfach selbständig generieren, da man ja nur die entprechenen Pins des RS232 Port ansteuern muss. Bei USB braucht man in der Regel immer einen USB Controller, der einem einiges an arbeit abnimmt.


	
